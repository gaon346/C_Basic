이번 강의에서는 가장 기본적인 연산자에 대해서 배웁니다.
덧셈(+),뺄셈(-),곱셈(*),나눗셈(/),나머지(%)에 대해서 알아보도록 하겠습니다.
-----------------------------------------------------------------------------------------------------

덧셈은+기호를 이용합니다.
출력할 떄 더한 겂을 따로 저장하지 않고 바로 출력할 수도 있으며, 물론 더한 값을 변수에 저장할 수도 있습니다.
물론 정수와 실수값을 더한 값은 실수형 자료형에 저장해야 합니다.

-----------------------------------------------------------------------------------------------------

나눗셈은 / 기호를 이용합니다.
일반적으로 정수와 정수끼리 나눗셈을 하면 몫이 결과 값이 되며,나머지 값은 버려집니다.
그러나 실수끼리 나눗셈을 하면 정상적으로 나머지값까지 저장됩니다.

-----------------------------------------------------------------------------------------------------
나머지는 나눗셈을 한 뒤에 남는 수를 의미하며, %기호를 이용합니다.
예를 들어 10 % 3 의 경우에는 3으로 나눈 후 남은 숫자가 1ㅣ므로 나머지는 1이 됩니다.
나머지 연산은 정수와 정수끼리만 가능합니다.
-----------------------------------------------------------------------------------------------------

증감연산자는 값을 1씩 증가시키거나 감소시키는 역할을 하고, 세부적으로 전위와 후위로 나뉘어져 있습니다.
값을 증가시키려면 ++, 값을 감소시키려면 --를 사용하면 됩니다.

-----------------------------------------------------------------------------------------------------

전위 연산의 경우에는 값을 증가시키거나 감소한 후에 연산자가 사용된 코드를 실행합니다.
그 줄에서 먼저 값이 증감된 후에 코드가 실행되는 것입니다.

후위 연산자의 경우에는 연산자가 사용된 코드를 먼저 실행한 후에 값을 증가시키거나 감소시키다.
그 다음 줄에서 값이 증감된다고 보시면 됩니다.

-----------------------------------------------------------------------------------------------------

값과 값과의 광걜 의 관걔 비교하는 관계 연산자에 대해서 배웁시다.
관계 연산자에는 두값이 같은지, 다른지, 큰지, 작거나 같은지 등을 비교해보자.

-----------------------------------------------------------------------------------------------------
C에서는 참이면 1, 거짓이면 0을 반환홥니다.
또한 값을 인식할 때에는 0을 거짓으로, 0 이외의 값을 참으로 판단합니다; 현재는 관 연산자가 딱히 필요없어 보이지만,
이 관계 연산자들은 후반부에 배우는 IF 같은 조건문에서 빛을 발합니다.
-----------------------------------------------------------------------------------------------------

참과 참, 거짓과 거짓, 참과 거짓 등을 논리 연산할 때 사용되는 논리 연산자를 배웁니다.
논리연산자에는 논리곱 연산과 논리합 연산이 존재하고, 기호로는 && 와 ||를 의미합니다.

논리곱 연산의 경우에는 양쪽이 둘다 참(1)이어야지만 결과값이 참(1)이 된다는 걸 알 수 있습니다.

논리합 연산의 경우에는 양쪽 중 하나만 참(1)이어도 결과값이 참(1)이 된다는 걸 알 수 있습니다.

-----------------------------------------------------------------------------------------------------

A += 5 는 A = A + 5를 출약시킨 형태
복합 대입 연산자에는 덧셈만이 있는 것이 아니며, 뺼셈, 곱셈, 나눗셈, 나머지 등
심지어 비트 연산자에도 동일하게 적용할 수 있습니다.


-----------------------------------------------------------------------------------------------------

비트 연산은 정수나 정수로 변환 가능한 타입만 가능하며, 실수나 포인터 등은 비트 연산을 할 수 없습니다.
비트는 바이트 단위보다 더 작은 단위이며, 2진수를 저장합니다.
즉 컴퓨터에서 사용할 수 있는 최소 단위이며 0과 1을 나타냅니다.

비트연산자는 적절한 때에 사용하면 메모리 공간의 효율성을 높이고 연산의 수를 줄일 수 있습니다.
또한 비트 단위로 계산하기 때문에 일반적인 사칙연산 연산자보다 훨씩 속도가 빠릅니다.

& AND연산
| OR연산
^ XOR연산
~ 모든 비트 반전, NOT연산
<<지정한 수만큼 비트 열을 왼쪽으로 이동
>>지정한 수만큼 비트 열을 오른쪽으로 이동

-----------------------------------------------------------------------------------------------------

먼저 & 연산자 입니다. 논리 연산자의 && 연산자와 헷갈릴 수 있는데, 논리 연산은 true 와 false를 반환하고 비트 연산은 값을 반환한다는 것을 기억하세요.

또한 "& 연산자는 주소값을 가리키는 거 아니었나?" 하고 어리둥절 하시는 분들도 계실겁니다. 맞습니다.
이 & 연산자는 조소값도 가리킵니다.
하지만 주소값을 가리키는 & 연산자는 단항연산자로써, 피연산자가 한개만 필요합니다.
즉 &b와 같이 한개의 변수만 필요하다는 뜻이지요.
이렇게 하나의 변수앞에서 쓰여질때는 주소값을 나타내지만, a & b와 같이 쓰여질 때는 비트의 AND연산자를 나타냅니다.

비트를 비교할때 각 수를 2진수로 변환한 후의 자리를 비교한다.
-----------------------------------------------------------------------------------------------------

signed의 경우 "부호있는 정수"라 하여 맨 왼쪽 비트는 부호비트입니다.
이 부호비트를 MSB(Most Significant Bit)라 부르며 0이면 양수, 1이면 음수를 나타냅니다.
따라서 MSB가 1이 되면 음수로 계산되어 보수연산을 하게 되는데,
이 보수연산이 조금 까다로우므로 부호비트에 영향을 주지 않도록 unsigned를 이용하였습니다.

-----------------------------------------------------------------------------------------------------

~연산은 NOT연산자로 AND, OR, XOR과 다르게 피연산자가 하나입니다.
즉, 한 값의 비트를 모두 반전시킵니다.
NOT연산자를 출력시 MSB가 1로 바껴서 음수가 출력되게 된다.
MSB가 1로 바뀌면 보수연산을 하게된다.

-----------------------------------------------------------------------------------------------------

<< 연산자는 지정한 횟수대로 비트의 자리를 왼쪽으로 이동시키는 연산자입니다.

4 << 1
0000 0100(4) -> 0000 1000(8)

6 << 3
0000 0110(6) -> 0011 0000(48)

비트 연산은 비트 단위에서 직접 조작하기 때문에 일반 사칙연산보다 더 빠릅니다.
따라서 상황에 따라 2의 N승 값을 곱할 때, 비트의 왼쪽이동연산으로 대체해서 사용할수 있습니다.

자료형을 주의해야 하는데, CHAR형의 경우 8비트지만
INT형의 경우 32비트이기 때문에 왼쪽으로 비트 이동을 할 때 잘리는 크기가 다릅니다.
또한 UNSIGNED 형의 경우 끝자리까지 정상적으로 이동하지만,
부호비트가 있는 자료형의 경우 MSB의 자리로 비트가 이동했을 때에 보수연산을 하게 됩니다.

그러니 비트 이동을 할때에는 자료형을 꼭 고려해야합니다.

-----------------------------------------------------------------------------------------------------

>> 연산자는 지정한 횟수대로 비트의 자리를 오른쪽으로 이동시키는 연산자입니다.

4 >> 1 : 2
0000 0100(4) -> 0000 0010(2)

이때 주의해야 할 비트는 MSB입니다. 오른쪽으로 이동하면서 생기는 빈 비트들을 채워야 하는데,
양수일때는 UNSIGNED 이든 SIGNED 이든 0이 채워져도 상관이 없습니다.
그러나 SIGNED 자료형이고 음수일 때에는 맨 왼쪽값이 1이어야 하는데,
이것을 0으로 채워야 할까요, 음수를 유지하기 위해 1로 채워야 할까요?

이 연산은 CPU마다 다릅니다. 어떤 CPU는 음수를 유지하기 위해 빈 비트들을 1로 채우고, 음수와는 상관없이 무조건 0을 채우는 CPU도 있습니다.
일반적으로 MSB와 같은 숫자를 채우는 쪽이 많습니다.

-16 >> 2 : -4
1111 0000(-16) -> 1111 1100(-4)
